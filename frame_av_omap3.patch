diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index c2b185b..7da68b1 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -85,6 +85,10 @@ ifeq ($(BOARD_USES_ALSA_AUDIO),true)
 endif
 endif
 
+ifeq ($(BOARD_USE_OMAP3_AV_ENHANCE),true)
+       LOCAL_CFLAGS += -DOMAP3_AV_ENHANCE
+endif
+
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
         $(TOP)/frameworks/native/include/media/hardware \
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index eebd61b..8f7a022 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -1312,6 +1312,9 @@ void AwesomePlayer::initRenderer_l() {
     if (USE_SURFACE_ALLOC
             && !strncmp(component, "OMX.", 4)
             && strncmp(component, "OMX.google.", 11)
+#ifdef OMAP3_AV_ENHANCE
+            && strncmp(component, "OMX.TI.", 7)
+#endif
             && strcmp(component, "OMX.Nvidia.mpeg2v.decode")) {
         // Hardware decoders avoid the CPU color conversion by decoding
         // directly to ANativeBuffers, so we must use a renderer that
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 98a0721..712ec8e 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -298,6 +298,34 @@ uint32_t OMXCodec::getComponentQuirks(
         quirks |= kRequiresWMAProComponent;
     }
 #endif
+    if (list->codecHasQuirk(
+                index, "needs-flush-before-disable")) {
+        quirks |= kNeedsFlushBeforeDisable;
+    }
+    if (list->codecHasQuirk(
+                index, "requires-flush-complete-emulation")) {
+      quirks |= kRequiresFlushCompleteEmulation;
+    }
+    if (list->codecHasQuirk(
+                index, "supports-multiple-frames-per-input-buffer")) {
+      quirks |= kSupportsMultipleFramesPerInputBuffer;
+    }
+    if (list->codecHasQuirk(
+                index, "input-buffer-sizes-are-bogus")) {
+      quirks |= kInputBufferSizesAreBogus;
+    }
+    if (list->codecHasQuirk(
+                index, "avoid-memcopy-input-recording-frames")) {
+      quirks |= kAvoidMemcopyInputRecordingFrames;
+    }
+    if (list->codecHasQuirk(
+                index, "requies-flush-before-disable")) {
+      quirks |= kNeedsFlushBeforeDisable;
+    }
+    if (list->codecHasQuirk(
+                index, "decoder-lies-about-nubmer-of-channels")) {
+      quirks |= kDecoderLiesAboutNumberOfChannels;
+    }
     return quirks;
 }
 
@@ -412,6 +440,23 @@ sp<MediaSource> OMXCodec::Create(
 #endif
         ALOGV("Attempting to allocate OMX node '%s'", componentName);
 
+#ifdef OMAP3_AV_ENHANCE
+        if (!strcmp(componentName, "OMX.TI.Video.Decoder")) {
+            int32_t width, height;
+            bool success = meta->findInt32(kKeyWidth, &width);
+            success = success && meta->findInt32(kKeyHeight, &height);
+            CHECK(success);
+            // We need this for 720p video without AVC profile
+            // Not a good solution, but ..
+            if (width*height > 412800) {  //860*480
+               componentName = "OMX.TI.720P.Decoder";
+               ALOGE("Format exceed the decoder's capabilities. %d", width*height);
+               continue;
+            }
+        }
+#endif
+
+
         if (!createEncoder
                 && (quirks & kOutputBuffersAreUnreadable)
                 && (flags & kClientNeedsFramebuffer)) {
@@ -603,6 +648,17 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             CODEC_LOGI(
                     "AVC profile = %u (%s), level = %u",
                     profile, AVCProfileToString(profile), level);
+
+            if (!strcmp(mComponentName, "OMX.TI.Video.Decoder")
+                && (profile != kAVCProfileBaseline || level > 31)) {
+                // This stream exceeds the decoder's capabilities. The decoder
+                // does not handle this gracefully and would clobber the heap
+                // and wreak havoc instead...
+
+                ALOGE("Profile and/or level exceed the decoder's capabilities.");
+                return ERROR_UNSUPPORTED;
+            }
+
         } else if (meta->findData(kKeyVorbisInfo, &type, &data, &size)) {
             addCodecSpecificData(data, size);
 
@@ -797,6 +853,12 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         setMinBufferSize(kPortIndexInput, (OMX_U32)maxInputSize);
     }
 
+    if (!strcmp(mComponentName, "OMX.TI.AMR.encode")
+        || !strcmp(mComponentName, "OMX.TI.WBAMR.encode")
+        || !strcmp(mComponentName, "OMX.TI.AAC.encode")) {
+        setMinBufferSize(kPortIndexOutput, 8192); // XXX
+    }
+
     initOutputFormat(meta);
 
     if ((mFlags & kClientNeedsFramebuffer)
@@ -900,6 +962,22 @@ status_t OMXCodec::setVideoPortFormatType(
              index, format.eCompressionFormat, format.eColorFormat);
 #endif
 
+        if (!strcmp("OMX.TI.Video.encoder", mComponentName)) {
+            if (portIndex == kPortIndexInput
+                    && colorFormat == format.eColorFormat) {
+                // eCompressionFormat does not seem right.
+                found = true;
+                break;
+            }
+            if (portIndex == kPortIndexOutput
+                    && compressionFormat == format.eCompressionFormat) {
+                // eColorFormat does not seem right.
+                found = true;
+                break;
+            }
+        }
+
+
         if (format.eCompressionFormat == compressionFormat
                 && format.eColorFormat == colorFormat) {
             found = true;
@@ -983,6 +1061,10 @@ status_t OMXCodec::findTargetColorFormat(
     int32_t targetColorFormat;
     if (meta->findInt32(kKeyColorFormat, &targetColorFormat)) {
         *colorFormat = (OMX_COLOR_FORMATTYPE) targetColorFormat;
+    } else {
+        if (!strcasecmp("OMX.TI.Video.encoder", mComponentName)) {
+            *colorFormat = OMX_COLOR_FormatYCbYCr;
+        }
     }
 
     // Check whether the target color format is supported.
@@ -1623,6 +1705,9 @@ OMXCodec::OMXCodec(
       mPaused(false),
       mNativeWindow(
               (!strncmp(componentName, "OMX.google.", 11)
+#ifdef OMAP3_AV_ENHANCE
+              || !strncmp(componentName, "OMX.TI.", 7)
+#endif
               || !strcmp(componentName, "OMX.Nvidia.mpeg2v.decode"))
                         ? NULL : nativeWindow)
 #ifdef QCOM_HARDWARE
@@ -3744,6 +3829,13 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     info->mStatus = OWNED_BY_COMPONENT;
 
+    // This component does not ever signal the EOS flag on output buffers,
+    // Thanks for nothing.
+    if (mSignalledEOS && !strcmp(mComponentName, "OMX.TI.Video.encoder")) {
+        mNoMoreOutputData = true;
+        mBufferFilled.signal();
+    }
+
     return true;
 }
 
diff --git a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
index 9bfa364..5ce81f1 100644
--- a/media/libstagefright/colorconversion/SoftwareRenderer.cpp
+++ b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
@@ -66,11 +66,24 @@ SoftwareRenderer::SoftwareRenderer(
 
     switch (mColorFormat) {
         case OMX_COLOR_FormatYUV420Planar:
+#ifdef OMAP3_AV_ENHANCE
+        /* OMX.TI.VideoDecoder decoding to OMX_COLOR_FormatYUV420Planar
+           is buggy (causing occasional DSP bridge resets), so we have
+           to use OMX_COLOR_FormatCbYCrY, which is reliable */
+        case OMX_COLOR_FormatCbYCrY:
+#endif
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
         {
             if (!runningInEmulator()) {
                 halFormat = HAL_PIXEL_FORMAT_YV12;
-                bufWidth = (mCropWidth + 1) & ~1;
+#ifndef OMAP3_AV_ENHANCE
+            bufWidth = (mCropWidth + 1) & ~1;
+#else
+            /* omap3.gralloc.so 8 aligns the stride of YV12 buffer
+            instead of 16 align, so we have to align the width ourselves
+            to avoid broken playback of videos with width not multiple of 16 */
+            bufWidth = ALIGN(mCropWidth, 16);
+#endif
                 bufHeight = (mCropHeight + 1) & ~1;
                 break;
             }
@@ -159,7 +172,11 @@ void SoftwareRenderer::render(
 
     GraphicBufferMapper &mapper = GraphicBufferMapper::get();
 
+#ifndef OMAP3_AV_ENHANCE
     Rect bounds(mCropWidth, mCropHeight);
+#else
+    Rect bounds(buf->width, mCropHeight);
+#endif
 
     void *dst;
     CHECK_EQ(0, mapper.lock(
@@ -180,7 +197,14 @@ void SoftwareRenderer::render(
 
         uint8_t *dst_y = (uint8_t *)dst;
         size_t dst_y_size = buf->stride * buf->height;
+#ifndef OMAP3_AV_ENHANCE
         size_t dst_c_stride = ALIGN(buf->stride / 2, 16);
+#else
+        /* the above ALIGN of just the color plane stride would have
+           caused writes outside of the allocated buffer, so it has
+           to be avoided */
+         size_t dst_c_stride = buf->stride / 2;
+#endif
         size_t dst_c_size = dst_c_stride * buf->height / 2;
         uint8_t *dst_v = dst_y + dst_y_size;
         uint8_t *dst_u = dst_v + dst_c_size;
@@ -201,6 +225,52 @@ void SoftwareRenderer::render(
             dst_u += dst_c_stride;
             dst_v += dst_c_stride;
         }
+#ifdef OMAP3_AV_ENHANCE
+    } else if (mColorFormat == OMX_COLOR_FormatCbYCrY) {
+        const uint8_t *src = (const uint8_t *)data;
+
+        size_t dst_y_size = buf->stride * buf->height;
+        size_t dst_c_size = buf->stride * buf->height / 4;
+
+        /* small pillarbox for videos with width not multiple of 16, needed
+           because of bug in (proprietary) gralloc.omap3.so as it 8 aligns
+           the stride of YV12 buffer instead of the correct 16 align */
+        size_t pb_c_size = (buf->stride - mCropWidth) / 2;
+        size_t pb_c_l_size = pb_c_size / 2;
+        size_t pb_c_r_size = pb_c_size - pb_c_l_size;
+        size_t pb_y_l_size = pb_c_l_size * 2;
+
+        uint8_t *dst_y = (uint8_t *)dst;
+        uint8_t *dst_v = dst_y + dst_y_size;
+        uint8_t *dst_u = dst_v + dst_c_size;
+
+        size_t nl_src = mWidth * 2;         // next line offset - source
+        size_t n2l_dst_y = buf->stride * 2; // next 2 lines offset - dest y
+
+        dst_y += pb_y_l_size;
+        memset(dst_v, 0x80, pb_c_l_size);   // make the pillarbox black
+        memset(dst_u, 0x80, pb_c_l_size);
+        dst_v += pb_c_l_size;
+        dst_u += pb_c_l_size;
+        for (int i = 0; i < mCropHeight; i += 2) {
+            size_t pb_c_size_tmp = i < mCropHeight - 2 ? pb_c_size : pb_c_r_size;
+            for (int j = 0; j < mCropWidth; j += 2) {
+                dst_y[j] = src[1];
+                dst_y[j + 1] = src[3];
+                dst_y[j + buf->stride] = src[nl_src + 1];
+                dst_y[j + buf->stride + 1] = src[nl_src + 3];
+                *dst_v++ = (src[2] + src[nl_src + 2]) / 2;
+                *dst_u++ = (src[0] + src[nl_src]) / 2;
+                src += 4;
+            }
+            src += nl_src;
+            dst_y += n2l_dst_y;
+            memset(dst_v, 0x80, pb_c_size_tmp);
+            memset(dst_u, 0x80, pb_c_size_tmp);
+            dst_v += pb_c_size_tmp;
+            dst_u += pb_c_size_tmp;
+        }
+#endif
     } else {
         CHECK_EQ(mColorFormat, OMX_TI_COLOR_FormatYUV420PackedSemiPlanar);
 
