diff --git a/vm/alloc/Heap.cpp b/vm/alloc/Heap.cpp
index 65b3310..fcda9c3 100644
--- a/vm/alloc/Heap.cpp
+++ b/vm/alloc/Heap.cpp
@@ -220,13 +220,17 @@ static void *tryMalloc(size_t size)
          * lock, wait for the GC to complete, and retrying allocating.
          */
         dvmWaitForConcurrentGcToComplete();
-    } else {
-      /*
-       * Try a foreground GC since a concurrent GC is not currently running.
-       */
-      gcForMalloc(false);
+        ptr = dvmHeapSourceAlloc(size);
+        if (ptr != NULL) {
+            return ptr;
+        }
     }
-
+    /*
+     * Another failure.  Our thread was starved or there may be too
+     * many live objects.  Try a foreground GC.  This will have no
+     * effect if the concurrent GC is already running.
+     */
+    gcForMalloc(false);
     ptr = dvmHeapSourceAlloc(size);
     if (ptr != NULL) {
         return ptr;
@@ -714,9 +718,8 @@ void dvmCollectGarbageInternal(const GcSpec* spec)
  * suspend when the GC thread calls dvmUnlockHeap before dvmResumeAllThreads,
  * but there's no risk of deadlock.)
  */
-bool dvmWaitForConcurrentGcToComplete()
+void dvmWaitForConcurrentGcToComplete()
 {
-    bool waited = gDvm.gcHeap->gcRunning;
     Thread *self = dvmThreadSelf();
     assert(self != NULL);
     u4 start = dvmGetRelativeTimeMsec();
@@ -729,5 +732,4 @@ bool dvmWaitForConcurrentGcToComplete()
     if (end - start > 0) {
         ALOGD("WAIT_FOR_CONCURRENT_GC blocked %ums", end - start);
     }
-    return waited;
 }
diff --git a/vm/alloc/Heap.h b/vm/alloc/Heap.h
index 19e48cd..9875951 100644
--- a/vm/alloc/Heap.h
+++ b/vm/alloc/Heap.h
@@ -92,7 +92,7 @@ void dvmCollectGarbageInternal(const GcSpec *spec);
  * re-acquires the heap lock.  After returning, no garbage collection
  * will be in progress and the heap lock will be held by the caller.
  */
-bool dvmWaitForConcurrentGcToComplete(void);
+void dvmWaitForConcurrentGcToComplete(void);
 
 /*
  * Returns true iff <obj> points to a valid allocated object.
